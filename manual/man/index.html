<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Kiss Manual</title>

<meta name="description" content="Kiss Manual">
<meta name="keywords" content="Kiss Manual">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<h1 class="settitle" align="center">Kiss Manual</h1>







<div class="chapter" id="Introduction">
<h2 class="chapter">1 Introduction</h2>

<p>The <em>KISS Framework</em> is an application development framework for
developing web-based business applications, portable desktop
applications, and command-line utilities.  The main home for
<em>Kiss</em> is <a href="https://github.com/blakemcbride/Kiss">https://github.com/blakemcbride/Kiss</a>
</p>

<p>Kiss&rsquo; focus is on simplicity and development speed.  By being simple
to develop in, development and support of the application can occur
more rapidly.  Simplicity is achieved by abstracting away as much
common functionality as possible so that developer lines of code are
maximally applicable to the application solution rather than
infrastructure and support of the framework.  Throughout the
framework, business-normal defaults have been employed in order to
minimize commonly needed functionality.
</p>
<p>Another goal of the <em>Kiss</em> framework is to be a complete web-based
application development solution.  <em>Kiss</em> isn&rsquo;t a browser solution
alone, nor is it a back-end solution.  <em>Kiss</em> includes solutions for
both ends &ndash; although the two sides may largely be used independently.
</p>
<p><em>Kiss</em> attempts to create a consistent interface.  This can greatly
simply code even in simple cases.  For example, in terms of an input
text control, why would you disable/enable it with:
</p>
<div class="example">
<pre class="example">$('#id').prop('disable', false);
$('#id').prop('disable', true);
</pre></div>

<p>and then hide/show it with:
</p>
<div class="example">
<pre class="example">$('#id').hide();
$('#id').show();
</pre></div>

<p><em>Kiss</em> provides a consistent interface.  With <em>Kiss</em>, you would do:
</p>
<div class="example">
<pre class="example">$$('id').disable();
$$('id').enable();
$$('id').hide();
$$('id').show();
</pre></div>
    
<p><em>Kiss</em> is designed to be simple to get started with, simple to learn,
and simple to use.  <em>Kiss</em> does this while supporting important
technologies such as micro-services, front-end components, and SQL.
</p>
<p>The term <em>single page application</em> has several, subtly different,
meanings.  One meaning is that the entire application code is bundled
into a single file or HTTP GET request.  In that sense, <em>Kiss</em> is not a
single page application.  This makes no sense for a business
application that could have hundreds of screens.
</p>
<p>Another meaning of the term <em>single page application</em> is that there is
only a single <code>html</code> tag and all of the remaining pages are
modifications of the original <code>html</code> tag contents.  In this
sense, <em>Kiss</em> is a <em>single page application</em>.  <em>Kiss</em>
applications lazy-load as needed.  Browser cache is leveraged to
minimize Internet traffic.
</p>
<p><em>Kiss</em> is used in a production environment and built by someone with
more than 30 years experience as a framework designer and a business
application software engineer.  So <em>Kiss</em> is not a proof of concept.
</p>
<p><em>Kiss</em> was built as a solution to the challenges faced by the author
when developing web-based business applications.  As such, <em>Kiss</em> is
more a solution for business application development than for the
development of public facing company presentation web sites.
</p>
<p>Another goal of <em>Kiss</em> is to keep the front-end and back-end as
independent of each other as possible.  To this end, communications
between the front-end and back-end occur via REST services and JSON.
This accomplished two things.  First, it allows your organization to be
best prepared for the ever-evolving software environment.  Pieces can
be changed and enhanced without causing massive re-writes of the entire
system.  The second advantage is that by pushing as much processing to
the front-end as possible (rendering the display on the front-end),
the system can better scale.
</p>
<ul class="section-toc">
<li><a href="#Kiss-Highlights" accesskey="1"><em>Kiss</em> Highlights</a></li>
<li><a href="#HTML-component-usage" accesskey="2">HTML component usage</a></li>
<li><a href="#System-Maturity-And-Future" accesskey="3">System Maturity And Future</a></li>
<li><a href="#Getting-All-Source-Code" accesskey="4">Getting All Source Code</a></li>
<li><a href="#Support_002c-Contact_002c-And-Links" accesskey="5">Support, Contact, And Links</a></li>
<li><a href="#License" accesskey="6">License</a></li>
<li><a href="#Acknowledgments" accesskey="7">Acknowledgments</a></li>
</ul>
<div class="section" id="Kiss-Highlights">
<h3 class="section">1.1 <em>Kiss</em> Highlights</h3>

<p>Some highlights of the <em>Kiss</em> system include:
</p>
<ul class="section-toc">
<li><a href="#Back_002dend-Highlights" accesskey="1">Back-end Highlights</a></li>
<li><a href="#Front_002dend-Highlights" accesskey="2">Front-end Highlights</a></li>
<li><a href="#Back_002dend-Web-Service-Example" accesskey="3">Back-end Web Service Example</a></li>
<li><a href="#Front_002dend-Web-Service-Usage-Example" accesskey="4">Front-end Web Service Usage Example</a></li>
</ul>
<div class="subsection" id="Back_002dend-Highlights">
<h4 class="subsection">1.1.1 Back-end Highlights</h4>

<ol>
<li> Micro services - add, change, or delete a web service on a running system.
</li><li> Each web-method is in a single file and are very simple.  No
configuration files or setup code needed.
</li><li> Easy access to common SQL databases with support for nested queries
without cursor interference.
</li><li> All REST services are stateless.  However, the system fully
authenticates each request.
</li><li> Changes to web services occur immediately, on a running system,
without the need to reboot the application.
</li><li> A growing class library to handle common business application needs.
</li><li> Back-end framework is written in Java, and the system is portable to
Linux or Windows servers.
</li><li> Web services may be written in Groovy, Java or Common Lisp.  Python,
JavaScript, Ruby, and Scala are expected to follow soon.
</li><li> User authentication
</li><li> Asynchronous back-end REST services (via a queue and thread pool)
provide support for heavy loads and high throughput.
</li><li> A powerful and convenient class library for dealing with SQL persistence that
supports PostgreSQL, Microsoft SQL Server, MySQL, Oracle, and SQLite.
</li></ol>

</div>
<div class="subsection" id="Front_002dend-Highlights">
<h4 class="subsection">1.1.2 Front-end Highlights</h4>

<ol>
<li> Build your own HTML components thus encapsulating any amount of code
into a simple, custom HTML tag.
</li><li> Browser cache control.  Never ask your users to clear their browser cache again.
</li><li> All code written in JavaScript/HTML/CSS.  No need for a complex build
and debug process, nor any need to learn yet another language.
</li><li> Growing list of included business oriented components designed to
provide simple access to fully functional business components.
</li><li> Straight forward means of designing your own components without a lot
of hidden and unpredictable magic.
</li><li> System is small and concise, rather then hundreds of megabytes other
systems take up.
</li><li> Consistent and simple API.
</li></ol>

</div>
<div class="subsection" id="Back_002dend-Web-Service-Example">
<h4 class="subsection">1.1.3 Back-end Web Service Example</h4>


<p>The following example depicts a complete back-end web service.  The
path to the file is its URL.  The class name is the web method name.
</p>
<p>The file is a text file, but compiled code gets executed.
Authentication occurs before <code>main</code> is called.
</p>
<p>Simply drop the file in place and the web service and method become
immediately available on a running system.  Changes to the service
take effect immediately (no need to reboot the server app).  There are
no configuration files or other code that needs to be changed.
</p>
<p>For example, the following file is located in the
<code>services</code> directory.
</p>
<div class="example">
<pre class="example">class MyWebService {
    void myWebMethod(JSONObject injson, JSONObject outjson) {
        int num1 = injson.getInt(&quot;num1&quot;);
        int num2 = injson.getInt(&quot;num2&quot;);
        outjson.put(&quot;result&quot;, num1 + num2);
    }
}
</pre></div>

</div>
<div class="subsection" id="Front_002dend-Web-Service-Usage-Example">
<h4 class="subsection">1.1.4 Front-end Web Service Usage Example</h4>

<p>The following front-end example utilizes the web service defined in the
previous sub-section.
</p>
<div class="example">
<pre class="example">let data = {
    num1:  22,
    num2:  11
};
let res = await Server.call(&quot;services/MyWebService&quot;, &quot;myWebMethod&quot;, data);
if (res._Success) {
    let result = res.result;
    //...
}
</pre></div>
    
</div>
</div>
<div class="section" id="HTML-component-usage">
<h3 class="section">1.2 HTML component usage</h3>
   
<p>To use a component add to HTML:
</p>
<div class="example">
<pre class="example">&lt;my-component&gt;&lt;/my-component&gt;
</pre></div>

<p>Add to JavaScript:
</p>
<div class="example">
<pre class="example">Utils.useComponent('MyComponent');
</pre></div>
    
<p>The component can put any HTML in the component location, have any
functionality, have its own modal windows, and use other components.
The component can have custom and non-custom attributes (like style).
Non-custom attributes do what you&rsquo;s expect them to do.
</p>
<p>The system also supports tag-less components.  This provides an easy
way to package arbitrary blocks of code (that can have screens too).
</p>
</div>
<div class="section" id="System-Maturity-And-Future">
<h3 class="section">1.3 System Maturity And Future</h3>

<p>Largely, the Kiss system, in the form of running applications, has
been used in production environments for a few years.  The effort to
tease away the generic parts and generalize them is recent (2018).
Moving forward, as time permits, the priorities are as follows:
</p>
<ol>
<li> Improve documentation
</li><li> More examples
</li><li> Greater front-end functionality (modal windows, grid control, etc. - note that these can be done by any other known facility.  They just don&rsquo;t come included with Kiss yet.)
</li><li> Support more back-end languages (such as Python, JavaScript, Ruby, etc.)
</li></ol>

</div>
<div class="section" id="Getting-All-Source-Code">
<h3 class="section">1.4 Getting All Source Code</h3>

<p>Source code for all of <em>Kiss</em> and its dependencies is freely
available.  The builder program located at
<code>src/main/core/org/kissweb/builder/Tasks.java</code> contains the paths
to all of the external dependencies (those not included in the
<em>Kiss</em> distribution).  The following lists the paths to the
internal dependencies (those included with <em>Kiss</em>):
</p>
<dl compact="compact">
<dt><span><code>abcl.jar</code></span></dt>
<dd><p><a href="https://common-lisp.net/project/armedbear">https://common-lisp.net/project/armedbear</a>
</p></dd>
<dt><span><code>json.jar</code></span></dt>
<dd><p><a href="https://github.com/blakemcbride/JSON-java">https://github.com/blakemcbride/JSON-java</a>
</p></dd>
<dt><span><code>SimpleWebServer.jar (only used during development)</code></span></dt>
<dd><p><a href="https://github.com/blakemcbride/SimpleWebServer">https://github.com/blakemcbride/SimpleWebServer</a>
</p></dd>
</dl>

</div>
<div class="section" id="Support_002c-Contact_002c-And-Links">
<h3 class="section">1.5 Support, Contact, And Links</h3>

<p>The <em>Kiss</em> main web site is at <a href="http://kissweb.org">http://kissweb.org</a>
</p>
<p>Source code is at <a href="https://github.com/blakemcbride/Kiss">https://github.com/blakemcbride/Kiss</a>
</p>
<p>Public discussion and support is available at <br> <a href="https://groups.google.com/forum/#!forum/kissweb">https://groups.google.com/forum/#!forum/kissweb</a>
</p>
<p>Issue tracking is at <a href="https://github.com/blakemcbride/Kiss/issues">https://github.com/blakemcbride/Kiss/issues</a>
</p>
<p>Commercial support is available.  Contact us via email at <a href="mailto:kissweb.org@gmail.com">kissweb.org@gmail.com</a>
</p>
</div>
<div class="section" id="License">
<h3 class="section">1.6 License</h3>

<p>Copyright (c) 2018 Blake McBride (blake@mcbridemail.com)
</p>
<p>Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
&ldquo;Software&rdquo;), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
</p>
<p>1. Redistributions of source code must retain the above copyright
notice, this list of conditions, and the following disclaimer.
</p>
<p>2. Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
&ldquo;AS IS&rdquo; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</p>
</div>
<div class="section" id="Acknowledgments">
<h3 class="section">1.7 Acknowledgments</h3>

<p>The Kiss design, code, documentation, and web site were written by
Blake McBride.  The author gratefully acknowledges and appreciates,
among others, the following:
</p>

<p>Apache Groovy located at <a href="http://groovy-lang.org">http://groovy-lang.org</a>
</p>
<p>Dynamic Loader located at <a href="https://github.com/dvare/dynamic-loader">https://github.com/dvare/dynamic-loader</a>
</p>
<p>JSON-Java located at <a href="https://github.com/stleary/JSON-java">https://github.com/stleary/JSON-java</a>
(although I am using a modified version available at
<a href="https://github.com/blakemcbride/JSON-java">https://github.com/blakemcbride/JSON-java</a>)
</p>
<p>C3P0 located at <a href="https://www.mchange.com/projects/c3p0">https://www.mchange.com/projects/c3p0</a>
</p>
<p>Texinfo located at <a href="https://www.gnu.org/software/texinfo/">https://www.gnu.org/software/texinfo/</a>
</p>
<p>ABCL project located at <a href="https://common-lisp.net/project/armedbear">https://common-lisp.net/project/armedbear</a>
</p>
<p>Melaine Sarbey (<a href="mailto:melswildart@gmail.com">melswildart@gmail.com</a>) for creating the Kiss logo.
</p>



</div>
</div>
<div class="chapter" id="System-Setup">
<h2 class="chapter">2 System Setup</h2>

<span id="Important"></span><ul class="section-toc">
<li><a href="#Important-1" accesskey="1">Important</a></li>
<li><a href="#Super_002dQuick_002dStart" accesskey="2">Super-Quick-Start</a></li>
<li><a href="#Quick_002dStart-Checklist-1" accesskey="3">Quick-Start Checklist</a></li>
<li><a href="#Runtime-Environments" accesskey="4">Runtime Environments</a></li>
<li><a href="#Pre_002drequisites-1" accesskey="5">Pre-requisites</a></li>
<li><a href="#Download-Kiss-1" accesskey="6">Download Kiss</a></li>
<li><a href="#Documentation" accesskey="7">Documentation</a></li>
<li><a href="#Setup-And-Configuration-1" accesskey="8">Setup And Configuration</a></li>
<li><a href="#Bypassing-Authentication" accesskey="9">Bypassing Authentication</a></li>
<li><a href="#Building-The-System">Building The System</a></li>
<li><a href="#System-Upgrades">System Upgrades</a></li>
<li><a href="#What-Do-I-Do-With-It-Now_003f">What Do I Do With It Now?</a></li>
</ul>
<div class="section" id="Important-1">
<h3 class="section">2.1 Important</h3>

<p>The <em>Kiss</em> system comes with its own build system, so it doesn&rsquo;t
use build systems such as <em>ant</em>, <em>maven</em>, or <em>gradle</em>.
It works under Linux, Mac, Windows, etc. This included build system
will make things such as downloading remote libraries, installing and
configuring a web server, building <em>Kiss</em>, and running
<em>Kiss</em> for development purposes easy, intelligent, and automatic.
This new build system can be used in conjunction with your favorite IDE.
</p>
<p>The build system (called it <em>bld</em>) is small and written in Java.
Its source code is included with the <em>Kiss</em> source code.  So, a
Java compiler will be needed before anything will work.  
Java 8, 11, and 17 are supported.
</p>
<p>When building the system for the first time, <em>BLD</em> will
automatically download and cache required libraries (jar files), install and
configure the development server (tomcat), build the system, and it
can even be used to launch the development-mode server.  After building
the system the first time, application development proceeds without
any need for re-compiles or re-builds.
</p>
<p>The program that runs <em>BLD</em> is &ldquo;<em>bld</em>&rdquo; under Unix-like
systems and &ldquo;<em>bld.cmd</em>&rdquo; under Windows.  In this manual,
&ldquo;<em>bld</em>&rdquo; will be shown as &ldquo;<em>./bld</em>&rdquo;.  The &ldquo;./&rdquo; is
required under Linux and Mac but not under Windows.  When running on
Windows, use &ldquo;bld&rdquo; rather than &ldquo;./bld&rdquo; and the same for all the
other commands shown.
</p>
</div>
<div class="section" id="Super_002dQuick_002dStart">
<h3 class="section">2.2 Super-Quick-Start</h3>

<p>This is the simplest and shortest path to a running system.  It assumes:
</p>
<ol>
<li> you have a JDK installed
</li><li> you have an Internet connection
</li></ol>

<p>After doing a <code>git clone</code>, all that is needed is the following:
</p>
<div class="example">
<pre class="example">    ./bld  develop                      [Linux, Mac, BSD, etc.]
         -or-
    build-builder                       [Windows]
    bld  develop                        [Windows]
</pre></div>

<p>This will build the system, install tomcat, deploy the app, and run
the server.  At this point you will be able to go your browser at the
following URL:
</p>
<div class="example">
<pre class="example">    http://localhost:8000
</pre></div>

<p>Be sure not to use port 8080.  Although port 8080 will appear to work,
you will not be able to do front-end development while the system is
running.  Port 8000 will allow front-end development while the system
is running.
</p>
<p>At this point, you can do all development without any build
procedures.  You can add or change anything on the front-end or
back-end while the system is running.
</p>
<p>All application back-end code is located under the <code>src/main/backend</code>
directory.
</p>
<p>All application front-end code is located under the <code>src/main/frontend</code>
directory.
</p>
<p>If you change anything in either place, the system will notice the change 
and deliver it with the next request.
</p>

<span id="Quick_002dStart-Checklist"></span></div>
<div class="section" id="Quick_002dStart-Checklist-1">
<h3 class="section">2.3 Quick-Start Checklist</h3>

<p>This is a more detailed and expanded description of the same
super-quick-start.
</p>
<p>The following enumerates the steps necessary to get the system up and running:
</p>
<ol>
<li> See <a href="#Pre_002drequisites">Pre-requisites</a>
</li><li> See <a href="#Download-Kiss">Download Kiss</a>
</li><li> See <a href="#Setup-And-Configuration">Setup And Configuration</a>
</li><li> The development server can be run without an IDE by running: <code>./bld develop</code>
</li><li> Once the server starts up, you can access it on your browser by going to 
<code>http://localhost:8000</code>  You can also debug the back-end by
attaching to the process at port 9000.

<p>Alternatively, your IDE can be configured to run the development
process entirely through it.
</p></li></ol>

<p>Once the development server is running under <em>bld</em>, you can stop it 
by hitting any key.
</p>
</div>
<div class="section" id="Runtime-Environments">
<h3 class="section">2.4 Runtime Environments</h3>

<p>As shipped, there are two different environments that <em>Kiss</em> may
run in as follows:
</p>
<ol>
<li> Development
</li><li> Production
</li></ol>

<p>The <em>Production</em> scenario is created with a single command
(<code>./bld war</code>) and produces a single <code>war</code> file (located in
the <code>build.work</code> directory) that can be deployed to your production
environment.
</p>
<p>Before doing anything with the <em>Development</em> environment, it is
important that you have the <em>JAVA_HOME</em> environment variable set
correctly to the root of your JDK (Java Developer Kit).  Doing this
varies according to the OS you are using and various other Java
installation possibilities.  There are plenty of instructions on the
Internet for this.
</p>
<p>The <em>Development</em> environment consists of two servers.  One
serves the back-end REST services, and the second serves the front-end
HTML, CSS, and JavaScript files.  By using this method, both front-end
and back-end source files can be changed on a running system and take
effect immediately without any builds, compiles, server reboots,
re-deploys, or file copies.  (This is also true of a production
environment &ndash; with a single server &ndash; when the new files are put in place.)
</p>
<p>Back-end REST services are debugged, and edited through the IDE.
Saving a source file is all that is needed to have it take effect.
</p>
<p>The front-end (HTML, CSS, and JavaScript files) are served by a simple
server supplied with the <em>Kiss</em> system.  This server is only used
during the development process.  See <a href="#Front_002dend-Development">Front-end Development</a>.
(Source code to this server is available at
<a href="https://github.com/blakemcbride/SimpleWebServer">https://github.com/blakemcbride/SimpleWebServer</a>) Debugging the
front-end is done through the browser debugger.  There is no setup,
and the front-end server runs by executing a single command.
</p>
<span id="Pre_002drequisites"></span></div>
<div class="section" id="Pre_002drequisites-1">
<h3 class="section">2.5 Pre-requisites</h3>

<p>You should download and install the following pre-requisites.
</p>
<ol>
<li> Java JDK 8,11, or 17 from many sources including <a href="https://www.azul.com/downloads/zulu-community">https://www.azul.com/downloads/zulu-community</a> or 
<a href="https://docs.aws.amazon.com/corretto/latest/corretto-8-ug/downloads-list.html">https://docs.aws.amazon.com/corretto/latest/corretto-8-ug/downloads-list.html</a> or
<a href="https://developers.redhat.com/products/openjdk/download">https://developers.redhat.com/products/openjdk/download</a> or
<a href="https://adoptopenjdk.net">https://adoptopenjdk.net</a>
</li><li> An SQL database server (e.g.&nbsp;PostgreSQL, Microsoft SQL Server, MySQL,
Oracle, SQLite)
</li><li> IDE (e.g.&nbsp;<a href="https://www.jetbrains.com/idea">IntelliJ</a>, VSCode, NetBeans, eclipse)
</li><li> GIT source code control system
</li></ol>

<p>Correctly setting the <em>JAVA_HOME</em> environment variable to the root of your
JDK is necessary.  Setting this varies from OS to OS and also depends on where it
gets installed.  Instructions for setting this variable are all over the Internet.
</p>
<p>The system was built and tested with JDK 8, 11 and 17,
<a href="https://www.postgresql.org">PostgreSQL</a>,
<a href="https://www.jetbrains.com/idea">IntelliJ</a>, and
<a href="http://tomcat.apache.org">tomcat</a>.  Other environments such as
IIS, Glassfish, eclipse, should work fine but may require some
configuration.
</p>
<p><em>Kiss</em> comes with its own build system.  See <a href="#Important">Important</a>
</p>
<p>Install the above according to their instructions.
</p>
<ul class="section-toc">
<li><a href="#Groff-and-PDF" accesskey="1">Groff and PDF</a></li>
</ul>
<div class="subsection" id="Groff-and-PDF">
<h4 class="subsection">2.5.1 Groff and PDF</h4>

<p>The <em>Kiss</em> reporting facilities are dependent on the full
<em>groff</em> system and the ability to convert Postscript files to PDF
files.  This is generally true on Linux, however, the full
<em>groff</em> package may need to be installed.  Mac&rsquo;s are fine.  These
packages are not on Windows and must be installed.
</p>
<p>Correctly installing <em>groff</em> and <em>ghostscript</em> will allow the
reporting facilities to work under Windows.  They may be obtained from:
</p>
<p><a href="https://sourceforge.net/projects/ezwinports">https://sourceforge.net/projects/ezwinports</a>
</p>
<p><a href="https://www.ghostscript.com">https://www.ghostscript.com</a>
</p>

<span id="Download-Kiss"></span></div>
</div>
<div class="section" id="Download-Kiss-1">
<h3 class="section">2.6 Download Kiss</h3>

<p>Kiss is located at <a href="https://github.com/blakemcbride/Kiss">https://github.com/blakemcbride/Kiss</a>
</p>
<p>It can be downloaded via the following command:
</p>
<p><code>git clone https://github.com/blakemcbride/Kiss.git</code>
</p>
</div>
<div class="section" id="Documentation">
<h3 class="section">2.7 Documentation</h3>

<p>The <em>Kiss</em> documentation consists of three parts; this manual,
the detailed back-end API documentation contained in the JavaDocs, and
the detailed front-end API documentation.  The JavaDocs do not come
with the system, but you can generate them yourself with what is
provided.  See <a href="#javadoc">Creating JavaDocs</a>.
</p>
<p>This manual may be created in two forms.  The first is in an HTML
form.  The system comes with this.  You can also generate a nicely
formatted PDF file with the following commands (if you have all of the
formatting tools installed):
</p>
<div class="example">
<pre class="example">cd manual
make Kiss.pdf
</pre></div>

<p>Updates to the HTML file are achieved with the following commands:
</p><div class="example">
<pre class="example">cd manual
make
</pre></div>

<p>All of the documentation can be accessed with your browser.  For
example, if the root of <em>Kiss</em> is located at
<code>/my/home/path/kiss</code> then you will be able to access the three
manuals at the following URL&rsquo;s:
</p>
<div class="example">
<pre class="example">file:///my/home/path/kiss/manual/man/index.html

file:///my/home/path/kiss/build.work/javadoc/index.html

file:///my/home/path/kiss/manual/jsdoc/index.html
</pre></div>

<span id="Setup-And-Configuration"></span></div>
<div class="section" id="Setup-And-Configuration-1">
<h3 class="section">2.8 Setup And Configuration</h3>

<p>The system is configured by the contents of a single file
<code>src/main/backend/KissInit.groovy</code> A reboot of the web server
is required if any of the parameters in this file are changed.
</p>
<p>Given that <em>Kiss</em> is for business applications, it authenticates its
users.  In order for this to work, there is usually a database of valid
users.  This information is persisted in an SQL database.  Therefore a
database is normally required.  However, for testing purposes, if no
database is configured, the system will still run and allow any
username and password to succeed.
</p>
<p>As shipped, the system comes configured as follows:
</p>
<table>
<tr><td>Database type</td><td>SQLite</td></tr>
<tr><td>Host</td><td>localhost</td></tr>
<tr><td>Database</td><td>DB.sqlite</td></tr>
<tr><td>Database user</td><td>[empty]</td></tr>
<tr><td>Database user password</td><td>[empty]</td></tr>
</table>

<p>Valid options for the Database type are as follows:
</p>
<ul>
<li> PostgreSQL
</li><li> MicrosoftServer
</li><li> MySQL
</li><li> Oracle
</li><li> SQLite
</li></ul>

<p>Support for other databases is easy to add.
</p>
<p><em>setMaxWorkerThreads</em> defines how many REST services may be
processed in parallel.  Service requests beyond this are placed in a
FIFO queue and processed as worker threads become available.  This
capability drastically improves the system&rsquo;s ability to handle a large
number of simultaneous users.
</p>
<p>The remaining parameters should be self-explanatory.  Use the format
shown in the example.
</p>
<p>Although <em>Kiss</em> comes with a default demo database, another one
should be configured in live or more substantial development
environments.  An SQL script file, named <code>init.sql</code>, is included
with the system to initialize said database.  Application specific tables
may be added to this database.
</p>
<p>The default username is <em>kiss</em>, and the default password is
<em>password</em>
</p>
</div>
<div class="section" id="Bypassing-Authentication">
<h3 class="section">2.9 Bypassing Authentication</h3>

<p>On rare occasions, it is necessary to bypass authentication.  In other
words, be able to execute a web service without being logged in.  One
example of this is registering a new user.  If the user isn&rsquo;t already a
valid user, they can&rsquo;t execute services in order to register.
</p>
<p><em>Kiss</em> has a way of dealing with this scenario.  This is done in
the same configuration file where all of the configuration options are
located.  In the file <code>src/main/backend/KissInit.groovy</code>.  In
that file, you are able to specify specific web methods that may be
called without authentication.  That file has an example.
</p>
<p>It should be noted that it is recommended that something like a
<em>captcha</em> be used to at least be confident you are
communicating with a human.  Additionally, it should be noted that the
danger of providing unauthenticated services is somewhat mitigated by
the combination of <em>HTTPS</em> and <em>CORS</em>.
</p>
</div>
<div class="section" id="Building-The-System">
<h3 class="section">2.10 Building The System</h3>

<p>Although the system may be built with the included build system
(called <em>bld</em>) <em>or</em> your favorite IDE, the <em>bld</em>
system should be used for the initial step which downloads the external
dependencies (jar files).
</p>
<p>The build system included with <em>Kiss</em> (called <em>bld</em>) has
been tested on Linux, Mac, and Windows.  The system also includes an
<em>Ant</em> build file (named <em>build.xml</em>) that is only used for
IDE integration with the included <em>bld</em> system.
</p>
<p>The build system included with Kiss is written in Java and located
under the <em>src/main/core/org/kissweb/builder/</em> directory.  This
build system also includes two driver batch files / shell scripts used
to build and run the build system.  All that is needed to use this
system is a Java compiler.  (As a side note - this build system is
generic and can be used to build other types of projects.)
</p>
<p>The build process is run from the command-line.  No IDE is necessary.
There is no specific IDE integration.  None is needed because the system
is rarely built.  After the first build, application development is done
without any build process.
</p>
<p>The build system, which comes in source form, must be built before it
can be used to build <em>Kiss</em>.  Under Linux, Mac, BSD, etc., the
build system gets built automatically.  However, under Windows, the 
following command is needed once to build the build system:
</p>
<div class="example">
<pre class="example">    build-builder             [Windows]
</pre></div>

<p>Once the build system has been built, you can see what operations it
can perform by typing:
</p>
<div class="example">
<pre class="example">    ./bld listTasks           [Linux, Mac, BSD, etc.]
        -or-
    bld listTasks             [Windows]
</pre></div>

<p>Those tasks that require prior tasks will evoke the dependent tasks
automatically.  The system is smart enough not to repeat tasks that
are unneeded.
</p>
<p>The main tasks that will be of interest to you are as follows:
</p>
<dl compact="compact">
<dt><span><code>libs</code></span></dt>
<dd><p>This task is only required if you intend to use your IDE to build the
remainder of the system.  It installs the required dependencies.
</p></dd>
<dt><span><code>develop</code></span></dt>
<dd><p>This will cause the entire system to build (not repeating unnecessary
steps) and start up a tomcat instance to run the system in a
development mode.  The system will be available from your local
browser at <code>http://localhost:8000</code>.  You may debug the
application by attaching to the running <em>tomcat</em> server at port
9000.
</p></dd>
<dt><span><code>war</code></span></dt>
<dd><p>This will cause the system to generate the single file needed by a
production system.  It will end up in <em>build.work/Kiss.war</em>
</p></dd>
</dl>

<p>Other tasks which may be useful are as follows:
</p>
<dl compact="compact">
<dt><span><code>clean</code></span></dt>
<dd><p>This task removes all files built but retains files that were downloaded from
repositories (although <em>bld</em> caches those files anyway.)
</p></dd>
<dt><span><code>realclean</code></span></dt>
<dd><p>This removes all built and downloaded files so the system should be everything
you need to build it without any extraneous files
</p></dd>
<dt><span><code>all</code></span></dt>
<dd><p>This performs all of the steps necessary to setup and build the system but
doesn&rsquo;t start up the tomcat server.
</p></dd>
<dt><span><code>javadoc</code></span></dt>
<dd><p>This task creates the javadoc files that end up in <code>build.work/javadoc</code>
</p></dd>
<dt><span><code>kisscmd</code></span></dt>
<dd><p>This task creates a command-line JAR that can be used in a non-web, command-line application.
This is useful when creating applications that perform various utility functions.  This
JAR cannot be used in any web environment.  See <code>src/main/core/org/kissweb/Main.java</code>
</p></dd>
</dl>

<p>See <a href="#Important">Important</a> and See <a href="#Quick_002dStart-Checklist">Quick-Start Checklist</a>.
</p>
<ul class="section-toc">
<li><a href="#Using-an-IDE" accesskey="1">Using an IDE</a></li>
</ul>
<div class="subsection" id="Using-an-IDE">
<h4 class="subsection">2.10.1 Using an IDE</h4>

<p>Most IDE&rsquo;s can be used to develop and debug the application.  There are two
way to do this as follows:
</p>
<ol>
<li> Using <em>bld</em> to build and run the development environment.
</li><li> Using your IDE to build and run the development environment.
</li></ol>

<p>Using <em>bld</em> to build and run the development environment is the
easiest to start off with but is somewhat klunky on an ongoing basis.
Its main advantage is that it is portable and doesn&rsquo;t require a lot of
IDE configuration.  The back-end development server is configured and
started by <em>bld</em> by simply running <em>./bld develop</em> After
that, the IDE can be used to debug it by <em>attaching</em> to port
9000.
</p>
<p><em>Kiss</em> also comes with an <em>ant</em> build that simply calls the
native <em>bld</em> program.  This is useful as an intermediary between
<em>bld</em> and the IDE since many IDE&rsquo;s support <em>ant</em>.
</p>
<p>Using your IDE to run the entire process is a bit tedious to initially
setup but makes the entire process simpler from that point forward.
Unfortunately, configuring your IDE is completely different for each
IDE.  Instructions for setting up some of the IDEs is located under the
<code>manual/IDE-Setup</code> directory.
</p>

</div>
</div>
<div class="section" id="System-Upgrades">
<h3 class="section">2.11 System Upgrades</h3>

<p>The <em>Kiss</em> framework is continually enhanced.  <em>Kiss</em>
includes a mechanism to upgrade your application.  However, this
automated upgrade process currently only works on Unix-like operating
systems such as macOS and Linux.  On Windows, a manual process will
need to be employed.
</p>
<p>The process of upgrading your application is as follows:
</p>
<ol>
<li> Go to the directory containing a clone of the <em>Kiss</em> framework (not your application).
</li><li> Update your clone via: <code>git pull</code>
</li><li> While remaining in the <em>Kiss</em> clone directory (and not your application directory),
run the following command:  <code>./upgrade-application &lt;path-to-your-application&gt;</code>
</li></ol>

<p><strong>Caveat</strong>
</p>
<p>While this upgrade process upgrades the majority of the system, there
are a few files that are not auto-updated to be sure not to clobber
possible application-specific code that may have been added.
Therefore, the following files will need to be manually verified.
</p>
<ul>
<li> <code>src/main/core/org/kissweb/builder/Tasks.java</code>

<p>This file is left untouched by the upgrade process.  You may have
custom tasks or modified existing tasks.  Be sure to check
<code>buildForeignDependencies()</code>.
</p></li><li> <code>libs</code>

<p>The upgrade process installs new or updated JAR files that are part of
the <em>Kiss</em> system.  However, you may have added
application-specific JAR files.  After the upgrade, be sure to manually delete any
outdated JAR files that come with <em>Kiss</em> that have been upgraded
by this process.
</p></li></ul>


</div>
<div class="section" id="What-Do-I-Do-With-It-Now_003f">
<h3 class="section">2.12 What Do I Do With It Now?</h3>

<p>What you have at this point is the beginnings of your new application.
<em>Kiss</em> is provided as a running and deployable system.  It is
expected that you would modify what&rsquo;s there to suit your application
needs.
</p>
<p>Besides this narrative, you would need the JavaDocs located under the
<code>build.work/javadoc</code> directory for back-end API specific documentation and
front-end API reference located in the <em>manual/jsdoc</em> directory.
</p>


</div>
</div>
<div class="chapter" id="Orientation">
<h2 class="chapter">3 Orientation</h2>


<p>The entire source code comes with the system and is convenient when
debugging, however, only a few areas in the system would normally be
of concern when building an application as follows.
</p>

<ul class="section-toc">
<li><a href="#Back_002dend-Application-Files" accesskey="1">Back-end Application Files</a></li>
<li><a href="#Front_002dend-Application-Files" accesskey="2">Front-end Application Files</a></li>
<li><a href="#Database" accesskey="3">Database</a></li>
<li><a href="#Single-Page-Application" accesskey="4">Single Page Application</a></li>
<li><a href="#Controlling-Browser-Cache" accesskey="5">Controlling Browser Cache</a></li>
<li><a href="#Creating-JavaDocs" accesskey="6">Creating JavaDocs</a></li>
<li><a href="#Deploying-A-Kiss-Application" accesskey="7">Deploying A Kiss Application</a></li>
<li><a href="#Learning-The-System" accesskey="8">Learning The System</a></li>
</ul>
<div class="section" id="Back_002dend-Application-Files">
<h3 class="section">3.1 Back-end Application Files</h3>

<dl compact="compact">
<dt><span><code>src/main/backend/KissInit.groovy</code></span></dt>
<dd><p>This file is used to configure the system. See <a href="#Setup-And-Configuration">Setup And Configuration</a>
</p></dd>
<dt><span><code>src/main/backend</code></span></dt>
<dd><p>All other files under this directory represent the application
back-end.  All the files are used and distributed in source form.  The
Kiss system compiles them at runtime but does not save the compiled form.
Updates to files under this directory take affect
immediately on a running system.
</p></dd>
</dl>


</div>
<div class="section" id="Front_002dend-Application-Files">
<h3 class="section">3.2 Front-end Application Files</h3>

<p>Files under the <code>src/main/frontend</code> directory represent the
front-end of the application.
</p>
<p>All files under the <code>src/main/frontend/kiss</code> directory are part of
the <em>Kiss</em> system and would normally not need to be touched.
</p>
<p><code>index.html</code> and <code>index.js</code> are also part of the <em>Kiss</em>
system and aren&rsquo;t normally modified.
</p>
<p><code>login.html</code> and <code>login.js</code> represent the user login page
and would be modified to suit your needs.
</p>
<p>Other directories such as <code>page1</code> represent other user pages and
would be the application specific screens you create.  The included
<code>page1</code> directory is only an example page.
</p>
</div>
<div class="section" id="Database">
<h3 class="section">3.3 Database</h3>

<p><em>Kiss</em> supports Microsoft SQL Server, Oracle, PostgreSQL, MySQL, and
SQLite.
</p>
<p>As shipped, <em>Kiss</em> comes configured with an embedded SQLite
server and database.  While this is fine for a demo or small
application, a real database should be configured for real use.
The included database is located in the <code>backend</code> directory
and is named <code>DB.sqlite</code>
</p>
<p>Although <em>Kiss</em> has no preferred database, PostgreSQL is strongly
recommended because it is free, full featured, fast, rock solid, and
portable on all major platforms.
</p>
<p>See <a href="#Setup-And-Configuration">Setup And Configuration</a>
</p>

</div>
<div class="section" id="Single-Page-Application">
<h3 class="section">3.4 Single Page Application</h3>

<p><em>Kiss</em> applications are single page applications in the sense
that there is a single <code>&lt;body&gt;</code> tag and all other pages
essentially get placed into that tag on a single page.  However,
<em>Kiss</em> is not a single page application in the sense that the
entire application gets loaded with a single <code>GET</code> request.  This
doesn&rsquo;t make sense for a large business application in which many
hundreds of pages may exist.  <em>Kiss</em> lazy-loads pages as they are
used, and except for browser cache, eliminates them once another page
is loaded.
</p>
</div>
<div class="section" id="Controlling-Browser-Cache">
<h3 class="section">3.5 Controlling Browser Cache</h3>

<p>The user&rsquo;s browser cache can be controlled from the file
<code>src/main/frontend/index.html</code> In that file you will see two lines
that look as follows:
</p>
<div class="example">
<pre class="example">var softwareVersion = &quot;1&quot;;  // version of the entire system
var controlCache = false;   // normally true but use false during 
                            // debugging
</pre></div>

<p>If <code>controlCache</code> is set to <code>true</code>, each time <code>softwareVersion</code>
is incremented all users starting the application will be forced to
load new code from the server and not use their browser&rsquo;s cache.  Once
they download the new version, normal browser cache activity will
occur.
</p>

<span id="javadoc"></span></div>
<div class="section" id="Creating-JavaDocs">
<h3 class="section">3.6 Creating JavaDocs</h3>

<p>JavaDocs for the <em>Kiss</em> system will need to be created.  It is
created from the command line by issuing the following command:
</p>
<div class="example">
<pre class="example">./bld javadoc              [Linux, Mac, BSD, etc.]
    -or-
bld javadoc                [Windows]
</pre></div>

<p>The JavaDoc files end up in the <code>build.work/javadoc</code> directory.
</p>

</div>
<div class="section" id="Deploying-A-Kiss-Application">
<h3 class="section">3.7 Deploying A Kiss Application</h3>

<p>The only file needed to deploy the application is <code>Kiss.war</code> It
can be built by typing <code>./bld war</code> at a command prompt.
<code>Kiss.war</code> ends up in the <code>build.work</code> directory.  If you
have your IDE create the <code>Kiss.war</code> file, it will likely not
work.  The <em>Kiss</em> system requires a special build process because
application files are distributed in source form.  Therefore, <code>bld</code>
should be used to create the production WAR file.
</p>
<p>If using <em>tomcat</em>, <code>Kiss.war</code> should be placed in the
<code>webapps</code> directory.  When <em>tomcat</em> starts, it will see the
file, unpack it, and run it.  The application will be available at
<code>[HOST]/Kiss</code>
</p>
<p>Renaming <code>Kiss.war</code> to <code>ABC.war</code>, for example, will cause
the application path to change to <code>[HOST]/ABC</code>
</p>
</div>
<div class="section" id="Learning-The-System">
<h3 class="section">3.8 Learning The System</h3>

<p>In order to start getting a feel for how <code>Kiss</code> applications
function, in terms of the back-end, look at files in the
<code>src/main/backend/services</code> directory.  With <code>Kiss</code> you can
develop applications in several different languages.  The <code>services</code>
example shows the same code in all of the supported languages.
</p>
<p>In terms of the front-end, see the example files under <code>src/main/frontend/page1</code>
</p>


</div>
</div>
<div class="chapter" id="Developing">
<h2 class="chapter">4 Developing</h2>

<p>This section details the development process with <em>Kiss</em>.  The
details provided will be for IntelliJ but can be adapted to other
IDE&rsquo;s.  The use of an IDE is tremendously beneficial because of the
graphical debugging and intelligent code completion capabilities.
</p>
<p>A good development environment includes two separate servers running
on two different ports.  One serves the back-end REST services, and
the other serves the front-end HTML, JavaScript, and CSS files.  This
arrangement allows both front-end and back-end development without any
compiles, server reboots, file copies, or deployments.  Back-end and
front-end files can be edited and saved.  Their changes take effect
immediately.
</p>
<p>Of course, in a production environment, only a single server would be
utilized and front-end and back-end changes take effect immediately
there too.
</p>
<ul class="section-toc">
<li><a href="#Overview" accesskey="1">Overview</a></li>
<li><a href="#Back_002dend-Development" accesskey="2">Back-end Development</a></li>
<li><a href="#Front_002dend-Development-1" accesskey="3">Front-end Development</a></li>
<li><a href="#Reports-And-Exports" accesskey="4">Reports And Exports</a></li>
<li><a href="#Authentication" accesskey="5">Authentication</a></li>
</ul>
<div class="section" id="Overview">
<h3 class="section">4.1 Overview</h3>

<p>The following details the normal steps to boot up a development environment.
Once this environment is set up, it may remain active for the whole day.
There is rarely any reason to re-build or re-boot the development environment.
</p>
<p>Note that all of the command-prompt commands are executed from the
root of your application.
</p>
<ol>
<li> In a command-prompt, type:  <code>./view-log</code>

<p>This is where back-end messages appear. (Note that this command currently only works on Unix-like 
operating systems such as macOS and Linux.  It is only displaying a log file which can easily
be done on Windows without continual update.)
</p></li><li> In a second command-prompt, type:  <code>./bld develop</code>

<p>This builds the system and runs the back-end and front-end servers.
</p></li><li> In the IDE, attach to the Java process at port 9000.

<p>This will allow you to debug the back-end.
</p></li><li> From your browser, go to <a href="http://localhost:8000">http://localhost:8000</a>

<p>This is where you view and interact with your application.
</p></li><li> Open the <em>Developer tools</em> from within the browser.

<p>This is where you debug the front-end.
</p></li><li> Be sure to disable caching on the browser. (Otherwise, changes you make to 
the front-end will not immediately appear in the browser.)
</li></ol>

<p>At this point, development, testing, and debugging can occur unabated.
There should be no need to rebuild or bring anything down.
</p>
<p>Front-end changes will appear as soon as you re-load the page on your browser.
Back-end changes with take effect immediately.
</p>
</div>
<div class="section" id="Back_002dend-Development">
<h3 class="section">4.2 Back-end Development</h3>

<p>The back-end works differently in development and production
environments.  Although in both environments back-end and front-end
changes take effect immediately, setup of the production environment
copies all files into the production environment, whereas in a
development environment the source and production code are split.  In
order to facilitate rapid and easy development, it is important that
source files be used rather than the production copies during the
development process.  
</p>
<p>The system automatically detects the location of the application
source in most configurations.  However, this may be explicitly
set via a system environment variable (<code>KISS_ROOT</code>).  The
value of this environment variable should be the absolute path of the
root of the application source code.  The directory it indicates
should have a sub-directory named <code>src/main/backend</code>.
</p>


<ul class="section-toc">
<li><a href="#REST-Server" accesskey="1">REST Server</a></li>
<li><a href="#Application-Code" accesskey="2">Application Code</a></li>
<li><a href="#Cached-User-Data" accesskey="3">Cached User Data</a></li>
<li><a href="#Programming-Languages" accesskey="4">Programming Languages</a></li>
<li><a href="#Cron" accesskey="5">Cron</a></li>
<li><a href="#CORS" accesskey="6">CORS</a></li>
</ul>
<div class="subsection" id="REST-Server">
<h4 class="subsection">4.2.1 REST Server</h4>

<p>There are two different methods of running the back-end REST server as
follows.
</p>
<ul class="section-toc">
<li><a href="#IDE" accesskey="1">IDE</a></li>
<li><a href="#BLD" accesskey="2">BLD</a></li>
</ul>
<div class="subsubsection" id="IDE">
<h4 class="subsubsection">4.2.1.1 IDE</h4>

<p>Running of the IDE back-end requires the following:
</p>
<ol>
<li> The IDE is completely configured.
</li><li> The system was build with the IDE
</li></ol>

<p>Typically, the IDE manages a tomcat instance and serves up the core
back-end code serving the REST services.  That code detects that it is
running under an IDE and re-routes all back-end application files back
to the source directories.
</p>
<p>Although back-end files are edited in source form and run in compiled
form, back-end code can be debugged (including break-points) as if
they were compiled before the system was booted.
</p>
<p>Once the back-end server is up, application files changed under the
<code>src/main/backend</code> directory will take effect immediately.
</p>
</div>
<div class="subsubsection" id="BLD">
<h4 class="subsubsection">4.2.1.2 BLD</h4>

<p>Utilizing the included <em>Kiss build system (bld)</em> the many steps required 
to install and configure tomcat and the IDE are unnecessary.  The whole process
(for the back-end portion) can be done as follows:
</p>
<ol>
<li> From any stage (including having just downloaded the <em>Kiss</em> system) type
the following:  <code>./bld develop</code>

<p>Note 1.  You may have to first perform the one-time task of building
the <em>bld</em> system by typing: <code>./build-builder</code>
</p>
<p>Note 2.  Remember that all commands that start with <code>./</code> would drop
the <code>./</code> under Windows.
</p></li></ol>
<p>At this point, the back-end will be running.  From within your IDE you
can attach to the process at port 9000 to debug the back-end (including
breakpoints, etc.)
</p>
<p>Remember, however, that you won&rsquo;t be able to use or debug the application until
the front-end server is started too.
</p>
</div>
</div>
<div class="subsection" id="Application-Code">
<h4 class="subsection">4.2.2 Application Code</h4>

<p>All communications between the front-end and back-end occur over REST
services you define.  Each REST service exists in its own
file or class.  Web methods are methods within those classes.
</p>
<p>As architected, directories under <code>src/main/backend</code>
represent the application&rsquo;s REST services.  Each class / file under that
directory represents a web service.  The name of the class is the name
of the web service.
</p>
<p>Instance methods within the web service class represent REST methods
for that web service.  Each web method is passed four arguments as follows:
</p>
<dl compact="compact">
<dt><span><code>JSONObject injson</code></span></dt>
<dd><p>This represents the data that came from the front-end.
</p></dd>
<dt><span><code>JSONObject outjson</code></span></dt>
<dd><p>This represents the data being returned to the front-end.  It is pre-initialized with an empty <code>JSONObject</code>.
</p></dd>
<dt><span><code>Connection db</code></span></dt>
<dd><p>This is a pre-opened connection to the defined database (defined in <code>backend/KissInit.groovy</code>)
</p></dd>
<dt><span><code>MainServlet servlet</code></span></dt>
<dd><p>This is a rarely used servlet context argument.
</p></dd>
</dl>

<p>Basically what happens is:
</p>
<ol>
<li> The front-end makes a REST service call.
</li><li> The <code>Kiss</code> back-end receives the request.
</li><li> The user gets authenticated.
</li><li> A new database connection is formed, and a new database transaction is started.
</li><li> The requested web service is identified (and loaded and compiled if needed).
</li><li> The <code>outjson</code> object that is filled in by the web service that is to be returned to the front-end.
</li><li> Upon completion of the REST service, <em>Kiss</em> commits the transaction, closes the database connection, and returns <code>outjson</code> to the front-end.
</li><li> If, however, the REST service threw an exception, <em>Kiss</em> rolls back the transaction, closes the database, and sends an error return to the front-end.
</li></ol>

<p>Additional class and instance methods, that are not web methods, may
be defined and used within web service classes.
</p>
<p>Of course during this process, <code>Kiss</code> handles many possible error conditions.
</p>
<span id="cached_005fuser_005fdata"></span></div>
<div class="subsection" id="Cached-User-Data">
<h4 class="subsection">4.2.3 Cached User Data</h4>

<p>During the login process, user-specific data may be cached.  This
often occurs in the <code>login</code> Groovy method of the <code>Login</code>
application-specific class.
</p>
<p>Every web service has access to this data via the following method:
</p>
<div class="example">
<pre class="example">        servlet.getUserData().getUserData(&quot;dataName&quot;)
        servlet.getUserData().putUserData(&quot;dataName&quot;, &quot;datValue&quot;)
</pre></div>

<p>See <a href="#authentication">Authentication</a>
</p>
</div>
<div class="subsection" id="Programming-Languages">
<h4 class="subsection">4.2.4 Programming Languages</h4>

<p>At this point, <em>Kiss</em> supports the development of back-end REST
services in the Java, Groovy, or Common Lisp languages.  Groovy was
added first because it was easy, worked with the IDE well, and did all
that was needed.  (See the document <em>GroovyOverview</em> included
with <em>KISS</em>.) Java was added simply due to its natural
integration with the rest of the system.
</p>
<p>With <em>Kiss</em>, different web services can be written in different
languages.  You are not forced to use one or the other.
</p>
<p>Common Lisp (ABCL) was added due to this author&rsquo;s love of that
language.  Unlike Groovy and Java, Lisp has an impedance mismatch with
the core <em>Kiss</em> system that is written in Java.  For example, in
Java, one can have two methods with the same name in the same class
that differ only by their argument types.  This is not part of the
Common Lisp language.  Also, the foreign function interface in Lisp
requires some Lisp code to make the connection clear.  Due to this
connection code having to run, the Lisp interface is very slow on the
first call.  It is, however, reasonably fast on all subsequent calls.
The code that interfaces Java to Lisp is under the
<code>src/main/core/org/kissweb/lisp</code> directory.
</p>
<p>Do to the easy and natural connection between Java and many other JVM
languages, interfaces to those languages is very easy.  It is
anticipated that support for many of these other languages (such as
Scala, Clojure, JRuby, Jython, and Kotlin) will likely follow,
especially if there are requests.
</p>
</div>
<div class="subsection" id="Cron">
<h4 class="subsection">4.2.5 Cron</h4>

<p><em>Kiss</em> has the ability to run any number of commands at specified
intervals.  For example, you could run a process every hour and
another process every Tuesday at 3 PM, etc.  This facility echos 
the standard Unix or Linux <code>cron</code> facility.
</p>
<p>The file that determines what gets run and when is <br>
<code>src/main/backend/CronTasks/crontab</code>.  All tasks must be in
the <code>Groovy</code> language and exist in the
<code>src/main/backend/CronTasks</code> directory.
</p>
<p>All contents of the <code>src/main/backend/CronTasks</code> can be changed
on a running system.  The change will get noticed and take effect.
There is no need to restart the system.
</p>
<p>Look at the files in the <code>src/main/backend/CronTasks</code>
directory for samples and further documentation.
</p>
</div>
<div class="subsection" id="CORS">
<h4 class="subsection">4.2.6 CORS</h4>

<p>Typically, for security reasons, web servers prevent web services from
an application that didn&rsquo;t come from the same application.  This is
known as Cross-Origin Resource Sharing or CORS.  <em>Kiss</em> fully
supports this standard.  However, there are times when you do not want 
this protection during the development process.
</p>
<p>As shipped, <em>Kiss</em> fully supports CORS except for
<code>localhost:8000</code>.  This is needed for the development process and
would not cause a security problem in a production environment.
</p>
<p>The problem occurs when you are running your development environment
on a laptop or desktop but want to test on a mobile device.  In this
case, you would be running the server and the application on two
different devices (since we use two servers in the development
process).  In order to allow this (for development purposes only), you
would need to change the setting in
<code>src/main/frontend/WEB-INF/web.xml</code> See comments in that file for
instructions.  Note that if this file is changed, the <em>Kiss</em>
system will have to be rebuilt.  Do not leave the setting open in a
production environment!
</p>
<span id="Front_002dend-Development"></span></div>
</div>
<div class="section" id="Front_002dend-Development-1">
<h3 class="section">4.3 Front-end Development</h3>

<p>A separate server is used so that development files will be served
rather than the front-end that was present when the back-end server
was started.  This is the same whether your are using the IDE or
<em>bld</em> back-end server modes.
</p>
<p>Once the back-end and front-end servers are running, the front-end can
be debugged through your browser debugger (F12 on Chrome).
</p>
<p>In order to make this work, there are two steps that
need to be followed.
</p>
<ol>
<li> The front-end needs to know where the back-end is located.  This is
controlled in the file <code>src/main/frontend/index.js</code>.  That file
contains a line that looks as follows:
<div class="example">
<pre class="example">    Server.setURL('http://localhost:8080');
</pre></div>
<p>As shipped, that setting should be good in most cases.  Adjust as needed.
</p></li><li> A server needs to be running to serve the front-end code.  The
<em>Kiss</em> system comes with a simple server that performs this
function.  It is in a file named <code>SimpleWebServer.jar</code> on the
root of the <em>Kiss</em> system.  From the root of the <em>Kiss</em>
system, run the following command to run the front-end server:
<div class="example">
<pre class="example">   ./serve
</pre></div>
<p>or on Windows:
</p><div class="example">
<pre class="example">   serve.cmd
</pre></div>
</li></ol>
<p>(Source code to this simple server is available at 
<a href="https://github.com/blakemcbride/SimpleWebServer">https://github.com/blakemcbride/SimpleWebServer</a>)
</p>
<p>Once the front-end and back-end servers are up, you can access the development
environment through your browser at <code>http://localhost:8000</code>
</p>
<p>If you disable the browser cache through the browser developer console
settings, changes you make to the front-end will appear by just
reloading the page.  On Chrome, for example, the browser cache can be
turned off by going into the page debugger (F12), then
<code>settings</code>, and then select <code>Disable cache (while DevTools
is open)</code>
</p>
<p>You can now develop the front-end portion of your application by
editing files under the <code>src/main/frontend</code> directory.
</p>
<ul class="section-toc">
<li><a href="#Mobile-Interface" accesskey="1">Mobile Interface</a></li>
</ul>
<div class="subsection" id="Mobile-Interface">
<h4 class="subsection">4.3.1 Mobile Interface</h4>

<p>It is often necessary to support mobile devices.  Although many
applications support mobile applications through pages that use
responsive design, it is often the case that the pages are so
different between various platforms that the use of whole new pages is
simpler and more effective &ndash; especially for complex screens.
</p>
<p>Although <em>Kiss</em> has always supported responsive design,
<em>Kiss</em> also supports the ability to have different pages for
different platforms.  If you look at <code>src/main/frontend/index.js</code>
you will see how <code>Kiss</code> handles this.  Basically <code>Kiss</code>
detects the platform and loads different pages based on the platform.
</p>

</div>
</div>
<div class="section" id="Reports-And-Exports">
<h3 class="section">4.4 Reports And Exports</h3>

<p>Creating reports and exports requires both front-end and back-end components.
The back-end usually creates the file to be sent to the front-end.  It then returns
a path that the front-end can use to download the file.
</p>
<p><em>Kiss</em> provides the infrastructure needed to support this facility.
<em>Kiss</em> also manages and cleans up report files that are no longer needed.
</p>
<p>In terms of producing reports, <em>Kiss</em> leverages the facilities
provided by the common groff/tbl/mm utilities publicly available.
These facilities automatically handle paging, titles, page numbering,
tables, and overall formatting of your reports. See
<a href="https://www.gnu.org/software/groff">https://www.gnu.org/software/groff</a>
</p>
<p>In terms of producing CSV export files, see the back-end
<code>DelimitedFileWriter</code> class.
</p>
<p>When files are produced by the back-end, they are sent to the
front-end by just providing the URL to the file.  At that point, the
front-end <code>Utils.showReport</code> takes the URL returned by the back-end
and downloads the file.
</p>
<span id="authentication"></span></div>
<div class="section" id="Authentication">
<h3 class="section">4.5 Authentication</h3>

<p><em>Kiss</em> has built-in authentication.  However, each application has its
own method of storing and validating users.  Additionally, each application
may have its own user-specific data it may want to retain between web service
calls. <em>Kiss</em> has a generic and easy way of handling these needs.
</p>
<p>Application-specific user login and data is handled by the Groovy file
located in the <code>backend</code> directory named <code>Login.groovy</code>.
That file must have two methods; <code>login</code> and <code>checkLogin</code>.  
See that file for more details.
</p>
<p>See <a href="#cached_005fuser_005fdata">Cached User Data</a>
</p>


</div>
</div>
<div class="chapter" id="Front_002dend-API">
<h2 class="chapter">5 Front-end API</h2>

<p>The front-end API are all the facilities that run on the browser.
This includes HTML, CSS, JavaScript, image files, etc.  The <em>Kiss</em>
back-end does not produce or modify HTML or JavaScript code.  These
files are served, unaltered, by the server as they are on the back-end
disk.  The <code>Kiss</code> model is that the browser receives these files
from the server, and that they include all the code that the browser
needs to perform its function.  Besides these static files, all data
is communicated between the back-end and front-end via REST services.
</p>
<p>Having all of the display logic running on the front-end or user&rsquo;s
browser makes a lot of sense for the following reasons:
</p>
<ol>
<li> Minimize the dependence the front-end and back-end have on each other.  This means that one end can be changed without necessitating
the need for the other to change.  In other words, they are minimally dependent on each other.
<ol type="a" start="1">
<li> In this rapidly changing environment, minimizing dependencies means minimizing the amount of code that has to be changed as technology changes.
</li><li> Code is easier to understand and maintain since you don&rsquo;t have four totally different languages in the same file.
</li></ol>
</li><li> Push as much processing to the client side so that the back-end can scale easier.
</li></ol>

<p>All of this leads to the following:
</p><ol>
<li> Shorter development time
</li><li> Easier to maintain
</li><li> Be most prepared for future changes
</li><li> Reduces server costs
</li><li> Reduced development time and cost
</li></ol>

<p>The front-end API is documented in the file <code>manual/jsdoc/index.html</code>.
</p>


<ul class="section-toc">
<li><a href="#Calling-REST-Services" accesskey="1">Calling REST Services</a></li>
<li><a href="#Kiss-Components" accesskey="2">Kiss Components</a></li>
<li><a href="#Modal-Popup-Windows" accesskey="3">Modal Popup Windows</a></li>
<li><a href="#File-Uploads" accesskey="4">File Uploads</a></li>
<li><a href="#Utilities" accesskey="5">Utilities</a></li>
<li><a href="#Controlling-Browser-Cache-1" accesskey="6">Controlling Browser Cache</a></li>
<li><a href="#Additional-Resources" accesskey="7">Additional Resources</a></li>
</ul>
<div class="section" id="Calling-REST-Services">
<h3 class="section">5.1 Calling REST Services</h3>

<p>On the front-end, the class <code>Server</code> is what deals with the REST
communications between the front-end and back-end.  In it, there are a
handful of methods that deal with the environment such as the back-end
URL.  All communications between the back-end and front-end are done
with JSON.
</p>
<p>The way it works is the login service requires a username and
password, and it returns a login token (uuid).  That token is used in
all future calls, and it gets automatically invalidated after a certain
amount of non-use time.  There is no state kept on the back-end.  Each
REST call must login to the back-end with the provided token in order
to be authenticated to communicate.
</p>
<p>The method used to communicate is named <code>Server.call()</code>. It is passed the
path to the REST service, the REST service method name, and a JSON
object that is send to the back-end method.  A <code>Promise</code> is
returned that is used to obtain the result of the call.  This
can also be used with <code>async/await</code>.
</p>
<p>There is also a <code>logout</code> method that simply erases the
login token so that future communications cannot occur.
</p>
<p>The <code>Server</code> class also includes a method (<code>fileUploadSend</code>)
that makes it easy to upload files.
</p>
</div>
<div class="section" id="Kiss-Components">
<h3 class="section">5.2 Kiss Components</h3>


<p>Although HTML provides what is needed for real applications, it
provides those facilities in too low a level to be useful without a
lot of custom code.  Custom components (tags) allow you to encapsulate
that advanced behavior into what is used as and appears as native
functionality.
</p>
<p><em>Kiss</em> provides the ability to create your own custom HTML tags
or elements as well as use those provided by <em>Kiss</em>.  There are
two principal user methods that make this work.
<code>Utils.useComponent</code> is used to load either a <em>Kiss</em> defined
component or one you define yourself (there is no difference).  This
loads the JavaScript file that defines the new tag.  All of the
components that come with the <em>Kiss</em> system are under the
<code>src/main/frontend/kiss/component</code> directory.  You can see those
files for examples of how custom tags are defined.
</p>
<p>New application pages are loaded with the <code>Utils.loadPage</code>
method.  In addition to loading the HTML and JavaScript code
associated with that page, this method performs the processing
necessary to make the components work.  It does this intelligently so
that, for example, one component can use another component without any
special loading order requirement.
</p>
<p>Briefly, the code that describes the custom tag must describe what the
tag is replaced with.  Ultimately, it must boil down to straight HTML,
CSS, and JavaScript code.
</p>

<ul class="section-toc">
<li><a href="#Tagless-Components" accesskey="1">Tagless Components</a></li>
</ul>
<div class="subsection" id="Tagless-Components">
<h4 class="subsection">5.2.1 Tagless Components</h4>

<p>Let&rsquo;s say you have a pop-up window that allows a user to search for employees, or product, or whatever.
The user gets a variety of search capabilities and the selected item is returned. Let&rsquo;s further say
that you need this functionality in several places within your application.  These are tagless
components.  They aren&rsquo;t placed with a custom tag.  They are a response to an event like a button push.
Tagless components allow you to encapsulate a block of functionality (including pop-up windows) into
a neat package that can be re-used in any number of places.
</p>
<p>The method used to load tagless components is
<code>Utils.useTaglessComponent</code>.  Later, when the tagless component
is needed, one would execute <code>Kiss.MyComponent.run(in_data, on_exit)</code> (where
<code>MyComponent</code> is the name of your tagless component.  
<code>in_data</code> represents possible data passed to the component on entry.
<code>on_exit</code> is a function that gets executed when the component exits.
Arguments passed to <code>on_exit</code> are determined by the component.
</p>

</div>
</div>
<div class="section" id="Modal-Popup-Windows">
<h3 class="section">5.3 Modal Popup Windows</h3>

<p><em>Kiss</em> supports draggable, modal popup windows. <em>HTML</em> is
used to describe the layout of the popup, and JavaScript is used to
control the appearance of the popup.
</p>
<p>The <em>HTML</em> portion is represented as a top-level <code>popup</code> tag
that represents the entire popup.  Withing the top-level <code>popup</code>
there most be two child tags named <code>popup-title</code> and
<code>popup-body</code>.  The first represents the single line header, and
the second represents the body of the popup window.
</p>
<p>The top-level <code>popup</code> tag&rsquo;s attribute section must contain the following:
</p>
<dl compact="compact">
<dt><span><code>id=&quot;my-popup&quot;</code></span></dt>
<dd><p>an ID is needed to reference the popup
</p></dd>
<dt><span><code>width=&quot;600px&quot; height=&quot;300px&quot;</code></span></dt>
<dd><p>Set the height and width of the popup
</p></dd>
</dl>

<p>An examples is as follows:
</p>
<div class="example">
<pre class="example">&lt;popup id=&quot;my-popup&quot; width=&quot;600px&quot; height=&quot;300px&quot;&gt;
    &lt;popup-title&gt;The title&lt;/popup-title&gt;
    &lt;popup-body&gt;
        The content
        &lt;div style=&quot;display: inline-block; position: absolute; bottom: 20px; right: 20px;&quot;&gt;
            &lt;push-button id=&quot;cancel&quot; style=&quot;margin-left: 15px;&quot;&gt;Cancel&lt;/push-button&gt;
            &lt;push-button id=&quot;ok&quot; style=&quot;margin-left: 15px;&quot;&gt;Ok&lt;/push-button&gt;
        &lt;/div&gt;
    &lt;/popup-body&gt;
&lt;/popup&gt;
</pre></div>

<p>There are only two JavaScript functions used to control the popup.
</p>
<dl compact="compact">
<dt><span><code>Utils.popup_open(id [, focus-id])</code></span></dt>
<dd><p>open the popup indicated by the <code>id</code>, and if <code>focus-id</code> is present, set initial focus to that control
</p></dd>
<dt><span><code>Utils.popup_close()</code></span></dt>
<dd><p>close the most recent popup
</p></dd>
</dl>

<p>Your defined responses to the buttons on the popup determines your dealing with the
data on the popup and when to close it.
</p>
</div>
<div class="section" id="File-Uploads">
<h3 class="section">5.4 File Uploads</h3>

<p><em>Kiss</em> includes facilities that make it easy to upload a file or
multiple files.  The way to use it is as follows:
</p>
<p>The HTML would contain two controls; a file input and a button.  The file
input looks as follows:
</p>
<div class="example">
<pre class="example">&lt;file-upload id=&quot;myUpload&quot;&gt;Upload File&lt;/file-upload&gt;
</pre></div>

<p>The file input control allows the user to select the file or files to
be uploaded.  If multiple files are to be allowed the <code>multiple</code>
attribute should be added to the HTML.
</p>
<p>The button is used to activate the upload process.  Your code that
sends the file(s) to the server should be attached to this button.
</p>
<p>The <code>file-upload</code> control contains the helper functions
<code>numberOfUploadedFiles</code> and <code>getFormData</code>, and the main
function used to send the files is <code>fileUploadSend</code> in the
<code>Server</code> class.  The code would look like the following:
</p>
<div class="example">
<pre class="example">   $$('upload').onclick(async () =&gt; {
        if ($$('the-file').numberOfUploadFiles() &lt; 1) {
            Utils.showMessage('Error', 'You must first select a file to upload.');
            return;
        }
        const fd = $$('the-file').getFormData();
        let data = {
            var1: 22,    // just some random data we want to sent to the back-end
            var2: 33
        }
        const r = await Server.fileUploadSend('theService, 'theMethod', fd, data);
    });
</pre></div>

<p>Back-end code would look like this:
</p>
<div class="example">
<pre class="example">public void theMethod(JSONObject inJson, JSONObject outJson, MainServlet servlet) throws Exception {
    String var1 = inJson.getString(&quot;var1&quot;);
    String var2 = inJson.getString(&quot;var2&quot;);
    if (servlet.getUploadFileCount() == 0)
        throw new Exception(&quot;No file specified.&quot;);
        
    String originalFileName = servlet.getUploadFileName(0);
    
    
    BufferedInputStream bis = servlet.getUploadBufferedInputStream(0);
    // do something with the file stream
    bis.close();
    
         -or-
         
    String localFileName = servlet.saveUploadFile(0);
}
</pre></div>




</div>
<div class="section" id="Utilities">
<h3 class="section">5.5 Utilities</h3>

<p><em>Kiss</em> includes an ever-growing set of utilities to help deal with common tasks.
These utilities are located under the <code>src/main/frontend/kiss</code> directory and have names such as
<code>DateTimeUtils.js</code>, <code>DateUtils</code>, <code>TimeUtils</code>, <code>Utils</code>, etc.  These utilities
are documented in the front-end API documentation.
</p>
</div>
<div class="section" id="Controlling-Browser-Cache-1">
<h3 class="section">5.6 Controlling Browser Cache</h3>

<p>Browser&rsquo;s have a mind of their own in term of deciding when to use
their cache for a file and when to download a new one.  This can cause
no end of trouble when code gets changed.  Some user files end up
being old from the browser cache, and others are freshly downloaded.
The old and new files don&rsquo;t agree with each other and all sorts of
errors occur.
</p>
<p><em>Kiss</em> includes a facility to assure that all files are
downloaded afresh whenever the application changes while still taking
maximal advantage of the browser cache when the files have not
changed.  The only cost for this capability is the requirement
that the <code>index.html</code> file <em>always</em> gets loaded afresh.
To that end, <em>Kiss</em> has code to ignore browser cache and always load
<code>index.html</code> afresh.
</p>
<p><code>index.html</code> contains two variables names <code>softwareVersion</code> and <code>controlCache</code>.
Assuming <code>controlCache</code> is <code>true</code>, <em>Kiss</em> has code that forces the browser
to re-load all files whenever <code>softwareVersion</code> changes.  After the code is re-loaded,
the browser cache will work as normal to maximally cache the files until the next
<code>softwareVersion</code> change.
</p>
</div>
<div class="section" id="Additional-Resources">
<h3 class="section">5.7 Additional Resources</h3>

<p>Although not a part of the <em>Kiss</em> system, there are some very
valuable technologies and libraries that have been used with
<em>Kiss</em> in order to create some very powerful solutions.
</p>
<p>The first is the Lovefield library that adds SQL capabilities on the
browser side.  Data is persisted on the user&rsquo;s browser and remains
through browser or machine re-boots.  The library is located at
<a href="https://github.com/google/lovefield">https://github.com/google/lovefield</a>
</p>
<p>A recent technology that has been used to enable browser application
that run when there is no Internet connection is called <em>Service
Workers</em>.  There is a package at <br>
<a href="https://developers.google.com/web/tools/workbox">https://developers.google.com/web/tools/workbox</a> that makes
working with service workers very easy.
</p>





</div>
</div>
<div class="chapter" id="Back_002dend-API">
<h2 class="chapter">6 Back-end API</h2>

<p>In addition to the full API provided by the Java system, and any additional
JAR files you add, <em>Kiss</em> comes with an API that assists with the
development of business application with <em>Kiss</em>.  These 
API&rsquo;s may be broadly grouped as follows:
</p>
<ol>
<li> Database API
</li><li> JSON API
</li><li> Utilities
</li></ol>

<p>An overview of these API&rsquo;s is contained in this chapter.  Detailed
documentation is contained in the JavaDocs.  See <a href="#javadoc">Creating JavaDocs</a>.
</p>
<ul class="section-toc">
<li><a href="#Database-API" accesskey="1">Database API</a></li>
<li><a href="#Microservices" accesskey="2">Microservices</a></li>
<li><a href="#JSON" accesskey="3">JSON</a></li>
<li><a href="#Utilities-1" accesskey="4">Utilities</a></li>
</ul>
<div class="section" id="Database-API">
<h3 class="section">6.1 Database API</h3>

<p><em>Kiss</em> comes with a powerful library for accessing SQL databases.
Code for this is located under <code>org.kissweb.database</code> It is
currently being used in production environments.  This API provides
the following benefits:
</p>
<ul>
<li> Automatic connection and statement pooling
</li><li> Vastly simpler API than bare JDBC
</li><li> Handling of parameterized arguments
</li><li> Auto generation of SQL for single record adds, edits, and deletions
</li><li> Auto handling for cases of cursor interference on nested queries
</li><li> Supports transactions out-of-the-box
</li></ul>

<p>As shipped, this library supports PostgreSQL, Microsoft Server,
Oracle, MySQL, and SQLite.
</p>
<p>The detailed documentation for the database utilities are in the
JavaDocs which you must generate. (See <a href="#javadoc">Creating JavaDocs</a>.)
This section provides an overview.
</p>
<p>The <em>Kiss</em> database routines revolve around four main classes as follows:
</p>
<dl compact="compact">
<dt><span><code>Connection</code></span></dt>
<dd><p>This represents a connection to an SQL database.
</p></dd>
<dt><span><code>Command</code></span></dt>
<dd><p>This represents a single action or command against the database.
</p></dd>
<dt><span><code>Cursor</code></span></dt>
<dd><p>If the action is a <code>select</code>, the <code>Cursor</code> represents a
pointer into the result set.
</p></dd>
<dt><span><code>Record</code></span></dt>
<dd><p>This class represents a single row within a table or result set.
</p></dd>
</dl>

<p>The <code>Connection</code> class contains several convenience methods that
are used in simple cases where only a single action is being
performed.  These methods should not be used when multiple
simultaneous actions are taking place at once (by that single thread).
This issue is not a problem in multi-user or multi-threaded
situations.  It is only a problem when a single thread is doing one
action while another action is still open.
</p>
<p>You will notice that your REST services are passed a <em>Connection</em>
argument.  <em>Kiss</em> automatically forms a unique connection for
each REST service call and closes it when the call is done.
Therefore, you will not normally need to create your own connection.
Additionally, <em>Kiss</em> automatically starts a new transaction with
each REST service and commits it when the service is done.  However,
if the service throws any exception, the transaction is rolled back
instead.
</p>
<p>You would not normally write SQL for single record adds, updates, and
deletes.  Using the <em>Record</em> API, <code>Kiss</code> automatically
generates these statements for you.
</p>
<p>In addition to the above, these utilities provide full support for transactions and parameters.
</p>
</div>
<div class="section" id="Microservices">
<h3 class="section">6.2 Microservices</h3>

<p>Microservices are classes that may be added, changed, or deleted while
the system is running.  In spite of this, however, all microservices
are fully compiled and run at full speed.  This has two major advantages.
</p>
<p>First, in a development environment, all development may be done without 
the need to bring the development server down, rebuild, re-deploy, and reboot
the development server.  This means development time is significantly reduced.
Additionally, IDE debuggers function in an environment such as this so
the debugging process may proceed normally.
</p>
<p>Second, in a production environment, the system may be upgraded
without disrupting existing users on the system.  Of course users
actively using the exact features you have just changed could be
affected (if their front-end and back-ends do not agree).
A simple re-try would put everything back in sync.
</p>
<p>Kiss microservices are on a class basis.  What that means is that a
microservice is always a single and whole class.  You cannot have more
than one class in a microservice.  Microservices can call
core components of the system just as regular methods can.  However,
if one wishes to have one microservice call another microservice,
the calling mechanism is a little more clunky.  However, using this
clunkier mechanism retains all of the dynamic features of the system.
</p>
<p>Defining microservices in Kiss involves defining a normal class just
as you would write a class in any circumstance.  No special
configuration, wiring, declarations, or additional steps are required.
Microservice additions, changes, and deletions take affect as soon as
you save the source file.  All microservices are compiled at runtime
by the system automatically.  So there is no compilation step that
you need to perform.
</p>
<p>The only caveat to the above is that remote microservices (described
below) expect a certain method signature (standard arguments).  This
is only to assure that the front-end and back-end can communicate as
expected.  Local microservices do not have this requirement.
</p>
<ul class="section-toc">
<li><a href="#Microservice-Language" accesskey="1">Microservice Language</a></li>
<li><a href="#Types-Of-Microservices" accesskey="2">Types Of Microservices</a></li>
<li><a href="#Remote-Microservices" accesskey="3">Remote Microservices</a></li>
<li><a href="#Defining-Remote-Services" accesskey="4">Defining Remote Services</a></li>
<li><a href="#Local-Microservices" accesskey="5">Local Microservices</a></li>
</ul>
<div class="subsection" id="Microservice-Language">
<h4 class="subsection">6.2.1 Microservice Language</h4>

<p>In Kiss, microservices can be written in Java, Groovy, or Common Lisp.
However, Groovy microservices have been used exclusively in all
current environments that we are aware of.  Therefore, Groovy
microservices are best tested.
</p>
<p>The reasons Groovy was used are as follows:
</p>
<ol>
<li> Groovy was the easiest and most natural to implement.
</li><li> Groovy runs as fast as Java and has full and natural access to all 
Java facilities.
</li><li> The actual loading of Groovy services is the fastest of the three languages.
</li><li> Groovy is largely a super-set of Java so if you know Java, you basically
know Groovy.  Learning of additional Groovy facilities can occur over
time.
</li><li> Groovy offers a small number of conveniences over Java.
</li></ol>

<p>Having said all this, however, all three languages are fully supported
and there are no known bugs in any of the languages supported.
</p>
</div>
<div class="subsection" id="Types-Of-Microservices">
<h4 class="subsection">6.2.2 Types Of Microservices</h4>

<p>There are two types of microservices as follows:
</p>
<ol>
<li> Remote (REST) Services
</li><li> Local Services
</li></ol>

<p>Remote services are generally called by a (likely JavaScript)
front-end or a remote client typically over <em>HTTP</em> or
<em>HTTPS</em>.  Local services are services that are called locally,
from within the system as, for example, one microservice calling a
method in a different microservice.
</p>
</div>
<div class="subsection" id="Remote-Microservices">
<h4 class="subsection">6.2.3 Remote Microservices</h4>

<p>In <em>Kiss</em>, remote microservices appear to the outside world as
typical <em>REST</em> services.  They may be called by a
<em>JavaScript</em> front-end, web service client, or any other facility
that can talk to <em>REST</em> services.
</p>
<p><em>Kiss</em> <em>REST</em> services are asynchronous <em>HTTP</em> or
<em>HTTPS</em> services.  Internally they are processed utilizing a
thread pool to assure optimal CPU utilization.  The number of threads
in the thread pool is controlled by a configuration parameter given in
the <code>KissInit.groovy</code> file.
</p>
<p><em>Kiss</em> comes with <em>JavaScript</em> code so that <code>Kiss</code>
<code>REST</code> services can be easily accessed from a typical front-end.
This code resides in a single file and can and has been used by
alternative front-ends such as <em>Angular</em> and <code>React</code>.
</p>
<p>There is no need to handle authentication.  <em>Kiss</em> handles that
automatically.  So, when your web method is called, you know who
they are and that they have been authenticated.
</p>
</div>
<div class="subsection" id="Defining-Remote-Services">
<h4 class="subsection">6.2.4 Defining Remote Services</h4>

<p>Remote REST microservices typically reside under the
<code>backend/services</code> directory.  You can organize them any way you
like.  A microservice is equivalent to a class.  The class name is the
microservice name.  The methods in that class that have a certain
signature (particular set of arguments) are the web methods.
</p>
<p>A REST web microservice has the following signature:
</p>
<div class="example">
<pre class="example">void myMethod(JSONObject injson, 
              JSONObject outjson, 
              Connection db, 
              ProcessServlet servlet) {
...
}
</pre></div>

<dl compact="compact">
<dt><span>&lsquo;<samp>injson</samp>&rsquo;</span></dt>
<dd><p>This is a <code>JSON</code> object that contains all of the arguments passed
in from the front-end.
</p></dd>
<dt><span>&lsquo;<samp>outjson</samp>&rsquo;</span></dt>
<dd><p>This is a <code>JSON</code> object which will contain all of the results
sent back to the front-end.  Whatever is put in this object gets sent back to the front-end.
</p></dd>
<dt><span>&lsquo;<samp>db</samp>&rsquo;</span></dt>
<dd><p>This is a database connection that can be used to access the SQL database.  The
connection is unique and independent of all other services.
</p></dd>
<dt><span>&lsquo;<samp>servlet</samp>&rsquo;</span></dt>
<dd><p>This object provides access to various system facilities uniquely related
to this call.
</p></dd>
</dl>

<p>See <a href="#json">JSON</a> and the <code>JavaDoc</code> for additional information.
</p>

</div>
<div class="subsection" id="Local-Microservices">
<h4 class="subsection">6.2.5 Local Microservices</h4>

<p>Local microservices are simply regular classes.  They typically reside
in the <code>backend/services</code> directory organized anyway you like.
Although methods within a particular microservice/class can call each
other in the normal way, there is an extra step required for one
microservice to call method in a different microservice.  One of the
reasons for this is so the system can be certain the latest version of
the service is loaded and that it is fully compiled before you attempt
to use it.
</p>
<p>In Groovy, a method in one class/microservice can call a method
in a different class/microservice via the following methods.
</p>
<ul>
<li> GroovyService.run
</li><li> GroovyService.getMethod
</li></ul>

<p>See the <em>Javadoc</em>.
</p>
<span id="json"></span></div>
</div>
<div class="section" id="JSON">
<h3 class="section">6.3 JSON</h3>

<p>The first two arguments to all REST methods is <code>injson</code> and
<code>outjson</code>.  <code>injson</code> is a <code>JSONObject</code> that contains
the data passed in <em>from</em> the front-end.  <code>outjson</code> is a
pre-initialized, empty <code>JSONObject</code> that will be <em>returned
to</em> the front-end.  The rest service should read the data passed in
from <code>injson</code>, perform any needed processes, and put the result
into <code>outjson</code> to be returned to the front-end.
</p>
<p>A modified version of a publicly available JSON Java package is
included and used to access JSON from the front-end and create JSON to
return to the front-end.  This package has many methods but only a few are
commonly used.
</p>
<p>There are two main data type of interest.  They are <code>JSONObject</code> and
<code>JSONArray</code>.  They hold the JSON types indicated by their names.
</p>
<p>Command useful for getting data out of <code>injson</code>:
</p>
<ul>
<li> JSONObject.has(String key)
</li><li> JSONObject.getString(String key)
</li><li> JSONObject.getBoolean(String key)
</li><li> JSONObject.getInt(String key)
</li><li> JSONObject.getLong(String key)
</li><li> JSONObject.getDouble(String key)
</li><li> JSONObject.getFloat(String key)
</li><li> JSONObject.getJSONArray(String key)
</li><li> JSONArray.length()
</li><li> JSONArray.getString(int index)
</li><li> JSONArray.getBoolean(int index)
</li><li> JSONArray.getInt(int index)
</li><li> JSONArray.getLong(int index)
</li><li> JSONArray.getFloat(int index)
</li><li> JSONArray.getDouble(int index)
</li><li> JSONArray.getString(int index)
</li><li> JSONArray.getJSONArray(int index)
</li></ul>

<p>Again, <code>outjson</code> is supplied as a pre-initialized, but empty,
<code>JSONObject</code>.  It is up to the REST service code to populate it
with the return data.  Useful JSON utilities include the following:
</p>
<ul>
<li> JSONObject.put(String label, Object data)
</li><li> new JSONObject()
</li><li> new JSONArray()
</li><li> JSONArray.put(Object obj)
</li></ul>


</div>
<div class="section" id="Utilities-1">
<h3 class="section">6.4 Utilities</h3>

<p><em>Kiss</em> includes an ever-growing set of utilities to help deal with common tasks.
These utilities are located under the <code>src/main/core/org/kissweb</code> directory and have names such as
<code>DateTime.java</code>, <code>NumberFormat</code>, etc.  These utilities
are documented in the JavaDocs.
</p>


</div>
</div>
<div class="chapter" id="Command-Line-Utility">
<h2 class="chapter">7 Command Line Utility</h2>

<p>In addition to utilizing <em>Kiss</em> as a web application development
system, <em>Kiss</em> also provides a command line interface.  This interface
allows you to build quick but powerful utilities to do things like updating
a database, parsing a CSV file, interfacing with a third-party REST service,
and more.  Basically, all of <em>Kiss</em> is available except the <em>Kiss</em>
REST server.
</p>
<p>Although this system supports <em>PostgreSQL</em> out-of-the-box, it
also supports any of the other databases with a slightly more complex
command line.
</p>
<ul class="section-toc">
<li><a href="#Building-The-Utility" accesskey="1">Building The Utility</a></li>
<li><a href="#Using-The-System" accesskey="2">Using The System</a></li>
<li><a href="#Databases-Other-Than-PostgreSQL" accesskey="3">Databases Other Than PostgreSQL</a></li>
</ul>
<div class="section" id="Building-The-Utility">
<h3 class="section">7.1 Building The Utility</h3>

<p>The build system (<em>bld</em>) has the ability to build a <em>JAR</em>
file named <em>KissGP.jar</em>.  The <em>GP</em> stands for <em>Groovy</em>
and <em>PostgreSQL</em>.  Basically, it is a <em>JAR</em> file capable of
running <em>Groovy</em> scripts in the context of all of the <em>Kiss</em>
utilities including access to a <em>PostgreSQL</em> database.
</p>
<p>(It should be noted that although <em>Groovy</em> scripts are text /
source files, they nevertheless run at full compiled speed because
they are compiled at runtime.)
</p>
<p>To build the <em>JAR</em> file, type the following:
</p>
<div class="example">
<pre class="example">./bld KissGP
</pre></div>

<p>A file named <em>KissGP.jar</em> will be created in the <em>build.work</em>
directory.  That, in addition to the <em>JDK</em>, is all that is needed to
use the system.
</p>
</div>
<div class="section" id="Using-The-System">
<h3 class="section">7.2 Using The System</h3>

<p>To use the <em>Kiss</em> command line interface you first create the
<em>Groovy</em> program you would like to run.  It may use all of the
<em>Groovy</em> and <em>Kiss</em> API.  For example, let&rsquo;s start with
something simple.  Create the following file named
<em>test1.groovy</em>:
</p>
<div class="example">
<pre class="example">static void main(String [] args) {
    println &quot;Hello world!&quot;
}
</pre></div>

<p>You can then run the program as follows:
</p>
<div class="example">
<pre class="example">java -jar KissGP.jar test1
</pre></div>

<p><em>test1.groovy</em> can be extended arbitrarily to perform any function needed.
</p>
</div>
<div class="section" id="Databases-Other-Than-PostgreSQL">
<h3 class="section">7.3 Databases Other Than PostgreSQL</h3>

<p>Although <em>KissGP.jar</em> comes bundled with support for the
<em>PostgreSQL</em> database, <em>KissGP.jar</em> can support databases
other than <em>PostgreSQL</em> by adding the driver for the database and
using a slightly more complex command line as follows.
</p>
<p>To use <em>KissGP.jar</em> with Microsoft SQL Server, for example, you&rsquo;d
have to include the database driver for it in addition to the
<em>KissGP.jar</em> file and the file with your program.  The command
line would look as follows:
</p>
<div class="example">
<pre class="example">java -cp mssql-jdbc-8.2.0.jre8.jar -jar KissGP.jar test1
</pre></div>

<p>The same is true of the other databases.  Please note that the drivers
you&rsquo;ll need are already in the <em>libs</em> directory.
</p>




</div>
</div>
<div class="chapter" id="Desktop-Applications">
<h2 class="chapter">8 Desktop Applications</h2>

<p>Although there are no specific instructions, portable desktop
applications can be built utilizing <em>Kiss</em> in conjunction with
Electron (<a href="https://electronjs.org">https://electronjs.org</a>).  These
applications would be portable to Linux, Mac, Windows, and other
platforms with a single codebase.
</p>
<p><em>Kiss</em> would provide the back-end portion of the application as a
local server and could be written in Java, Groovy, or Lisp.  
</p>
<p>The front-end portion of <em>Kiss</em> would be used in conjunction with
<em>Electron</em> in <em>HTML</em>, <em>CSS</em>, and <em>JavaScript</em>.
</p>
<p>The two halves would communicate locally and operate as a standard
desktop application.
</p>
<p>If there is interest, please contact this author for assistance.
</p>

<hr></div>



</body>
</html>
